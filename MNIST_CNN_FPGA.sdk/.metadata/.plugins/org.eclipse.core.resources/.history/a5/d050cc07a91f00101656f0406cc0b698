#include <stdio.h>
#include "xparameters.h"
#include "xil_io.h"
#include "xscugic.h"
#include "xil_exception.h"

#define INTR_ID    XPAR_FABRIC_MYMNIST_CNN_0_DONE_INTR_O_INTR
#define BRAM_BASE  XPAR_BRAM_0_BASEADDR

static XScuGic Intc;
volatile int DoneFlag = 0;

// 1) 인터럽트 핸들러: 수행 후 재인에이블
void CnnDoneHandler(void *CallbackRef) {
    // 인터럽트 비활성화(스푸리어스 방지)
    XScuGic_Disable(&Intc, INTR_ID);
    DoneFlag = 1;
}

// 2) GIC + Cortex 초기화
int SetupInterrupts() {
    XScuGic_Config *Cfg = XScuGic_LookupConfig(XPAR_PS7_SCUGIC_0_DEVICE_ID);
    if (!Cfg) return XST_FAILURE;
    XScuGic_CfgInitialize(&Intc, Cfg, Cfg->CpuBaseAddress);

    // 인터럽트 우선순위/트리거 타입 설정 (레벨: 3)
    XScuGic_SetPriorityTriggerType(&Intc, INTR_ID, 0, 3);

    // 핸들러 연결
    XScuGic_Connect(
      &Intc,
      INTR_ID,
      (Xil_ExceptionHandler)CnnDoneHandler,
      NULL
    );
    XScuGic_Enable(&Intc, INTR_ID);

    // CPU 쪽 인터럽트 엔에이블
    Xil_ExceptionRegisterHandler(
      XIL_EXCEPTION_ID_INT,
      (Xil_ExceptionHandler)XScuGic_InterruptHandler,
      &Intc
    );
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

int main() {
    int i;

    // 1) 하드웨어 플랫폼은 이미 init_platform() / init_cache() 호출되어 있다고 가정

    // 2) 인터럽트 시스템 초기화
    if (SetupInterrupts() != XST_SUCCESS) {
        xil_printf("Interrupt setup failed\n\r");
        return XST_FAILURE;
    }

    // 3) CNN IP 동작 시작 (start_i 펄스 줘야 한다면 여기서)
    //    ...(여러분 코드)...

    // 4) 인터럽트 발생 대기
    while (!DoneFlag) {
        // idle
    }

    // 5) BRAM 에서 결과 읽기
    //    BRAM 너비가 32bit 이므로 4바이트씩 읽습니다.
    //    예: 총 N 결과 요소라면 i < N 으로.
    for (i = 0; i < 100; ++i) {
        u32 data = Xil_In32(BRAM_BASE + i*4);
        // 필요 시 바이트 단위로 전송:
        // uint8_t *p = (uint8_t*)&data;
        // for (int j=0; j<4; ++j) send_byte(p[j]);
        xil_printf("y[%2d] = 0x%08x\n\r", i, data);
    }

    // 6) 인터럽트 재엔에이블 (원한다면)
    DoneFlag = 0;
    XScuGic_Enable(&Intc, INTR_ID);

    return 0;
}
